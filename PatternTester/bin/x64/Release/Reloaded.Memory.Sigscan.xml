<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Reloaded.Memory.Sigscan</name>
    </assembly>
    <members>
        <member name="T:Reloaded.Memory.Sigscan.Scanner">
            <summary>
            Provides an implementation of a simple signature scanner sitting ontop of Reloaded.Memory.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.#ctor(System.Byte[])">
            <summary>
            Creates a signature scanner given the data in which patterns are to be found.
            </summary>
            <param name="data">The data to look for signatures inside.</param>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.#ctor(System.Diagnostics.Process,System.Diagnostics.ProcessModule)">
            <summary>
            Creates a signature scanner given a process and a module (EXE/DLL)
            from which the signatures are to be found.
            </summary>
            <param name="process">The process from which to scan patterns in. (Not Null)</param>
            <param name="module">An individual module of the given process, which denotes the start and end of memory region scanned.</param>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a signature scanner given the data in which patterns are to be found.
            </summary>
            <param name="data">The data to look for signatures inside.</param>
            <param name="length">The length of the data.</param>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.CompiledFindPattern(System.String)">
            <summary>
            Attempts to find a given pattern inside the memory region this class was created with.
            This method generates a list of instructions, which more efficiently determine at any array index if pattern is found.
            This method generally works better when the expected offset is bigger than 4096.
            </summary>
            <param name="pattern">
                The pattern to look for inside the given region.
                Example: "11 22 33 ?? 55".
                Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F
            </param>
            <returns>A result indicating an offset (if found) of the pattern.</returns>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.CompiledFindPattern(Reloaded.Memory.Sigscan.Structs.CompiledScanPattern,System.Int32)">
            <summary>
            Attempts to find a given pattern inside the memory region this class was created with.
            This method generally works better when the expected offset is bigger than 4096.
            </summary>
            <param name="pattern">
                The compiled pattern to look for inside the given region.
            </param>
            <param name="startingIndex">The index to start searching at.</param>
            <returns>A result indicating an offset (if found) of the pattern.</returns>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Scanner.SimpleFindPattern(System.String,System.Int32)">
            <summary>
            Attempts to find a given pattern inside the memory region this class was created with.
            This method uses the simple search, which simply iterates over all bytes, reading max 1 byte at once.
            This method generally works better when the expected offset is smaller than 4096.
            </summary>
            <param name="pattern">
                The pattern to look for inside the given region.
                Example: "11 22 33 ?? 55".
                Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F
            </param>
            <param name="startingIndex">The index to start searching at.</param>
            <returns>A result indicating an offset (if found) of the pattern.</returns>
        </member>
        <member name="T:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern">
            <summary>
            Represents the pattern to be searched by the scanner.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.Pattern">
            <summary>
            The pattern the instruction set was created from.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.Length">
            <summary>
            The length of the original given pattern.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.Instructions">
            <summary>
            Contains the functions that will be executed in order to validate a given block of memory to equal
            the pattern this class was instantiated with.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.NumberOfInstructions">
            <summary>
            Contains the number of instructions in the <see cref="F:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.Instructions"/> object.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.#ctor(System.String)">
            <summary>
            Creates a new pattern scan target given a string representation of a pattern.
            </summary>
            <param name="stringPattern">
                The pattern to look for inside the given region.
                Example: "11 22 33 ?? 55".
                Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F.
            </param>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Structs.CompiledScanPattern.GenerateMaskAndValue(System.Span{System.String},System.UInt64@,System.UInt64@)">
            <summary>
            Generates a mask given a pattern between size 0-8.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Sigscan.Structs.PatternScanResult.Offset">
            <summary>
            The offset of the pattern if found, else -1.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Sigscan.Structs.PatternScanResult.Found">
            <summary>
            True if the pattern has been found, else false.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Structs.PatternScanResult.#ctor(System.Int32)">
            <summary>
            Creates a pattern scan result given the offset of the pattern.
            </summary>
            <param name="offset">The offset of the pattern if found. -1 if not found.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Reloaded.Memory.Sigscan.Structs.SimplePatternScanData" -->
        <member name="F:Reloaded.Memory.Sigscan.Structs.SimplePatternScanData.Bytes">
            <summary>
            The pattern of bytes to check for.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Structs.SimplePatternScanData.Mask">
            <summary>
            The mask string to compare against. `x` represents check while `?` ignores.
            Each `x` and `?` represent 1 byte.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Structs.SimplePatternScanData.#ctor(System.String)">
            <summary>
            Creates a new pattern scan target given a string representation of a pattern.
            </summary>
            <param name="stringPattern">
                The pattern to look for inside the given region.
                Example: "11 22 33 ?? 55".
                Key: ?? represents a byte that should be ignored, anything else if a hex byte. i.e. 11 represents 0x11, 1F represents 0x1F.
            </param>
        </member>
        <member name="T:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1">
            <summary>
            Creates a <see cref="T:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1"/> that allows for the efficient enumeration of a string
            to be split.
            </summary>
            <typeparam name="TSpanType">The item type held by the span..</typeparam>
        </member>
        <member name="P:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1.SplitItem">
            <summary>
            The item to split on.
            </summary>
        </member>
        <member name="P:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1.Current">
            <summary>
            The current state of the span.
            </summary>
        </member>
        <member name="F:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1._original">
            <summary>
            The original span this struct was instantiated with.
            </summary>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1.MoveNext">
            <summary>
            Moves the span to the next element delimited by the item to split by.
            </summary>
            <returns>True if the item has moved. False if there is no item to move to.</returns>
        </member>
        <member name="M:Reloaded.Memory.Sigscan.Utility.SpanSplitEnumerator`1.#ctor(System.ReadOnlySpan{`0},`0)">
            <summary>
            Creates an enumerator used to split spans by a specific item.
            </summary>
            <param name="item">The span to split items within.</param>
            <param name="splitItem">The item to split on.</param>
        </member>
    </members>
</doc>
